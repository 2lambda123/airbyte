import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage

class AirbyteDockerBmuschkoConfiguration {
    Collection<String> additionalDockerfileNames
    Collection<Task> additionalDependencies
    // By default, we will attempt to build both arm64 and amd64 images.
    // For modules which cannot be built as both of those architectures, this
    // option allows forcing a specific arch.
    String archOverride
}

/**
 * Creates a buildDockerImage-Dockerfile task, which equates to `docker build .`
 * Also creates 'buildDockerImage-*' tasks based on additionalDockerfileNames.
 *
 * Finally, creates a buildDockerImage task, which simply executes all of the buildDockerImage-* tasks.
 *
 * These tasks depend on project.assemble, and register themselves as dependencies of project.build. If other tasks need to run before buildDockerImage,
 * you can list them in additionalDependencies.
 */
class AirbyteDockerBmuschkoPlugin implements Plugin<Project> {
    void apply(Project project) {
        def extension = project.extensions.create('airbyteDockerBmuschko', AirbyteDockerBmuschkoConfiguration)

        // Create a noop task to aggregate all the individual Dockerfile builds together
        def allTask = project.task('buildDockerImage')

        // AirbyteDockerBmuschkoConfiguration's values aren't available until after Gradle fully evaluates the project, so we need to wait until that happens.
        project.afterEvaluate {
            // Create a task to copy all our files into build/docker.
            // Ideally, we'd just use the project dir as the input path, but the docker plugin isn't intended to be used that way,
            // and it causes a lot of problems for detecting whether the task is up to date.
            def copyFilesTask = project.task('setupDockerBuild', type: Sync) {
                from '.'
                into 'build/docker'

                excludes = [
                    // Exclude the directory we're trying to set up
                    'build/docker',
                    // misc docker working files (i.e. '*-imageId.txt')
                    'build/.docker',
                    // Java test files
                    'build/classes/java/integrationTestJava',
                    'build/classes/java/test',
                    'build/jacoco',
                    'build/test-results',
                    // Python working files
                    '.venv',
                    '**/.coverage.*',
                    '**/.pytest_cache',
                ]

                // If this is a Java project, then we can't run the Docker build until after the compiled tar exists
                dependsOn project.assemble
                extension.additionalDependencies.each(task -> dependsOn(task))
            }

            def dockerfileNames = extension.additionalDockerfileNames
            // Insert entry for Dockerfile
            if (!dockerfileNames) {
                dockerfileNames = ['Dockerfile']
            } else if (!dockerfileNames.contains('Dockerfile')) {
                dockerfileNames.add('Dockerfile')
            }

            // Create the individual build tasks
            dockerfileNames.each(dockerfileName -> {
                def buildDockerImageTask
                def taskName = "buildDockerImage-${dockerfileName}"
                if (project.file(dockerfileName).exists()) {
                    def imageName = DockerHelpers.getDevTaggedImage(project.projectDir, dockerfileName)
                    buildDockerImageTask = createTask(project, taskName, imageName, dockerfileName, extension.archOverride)
                } else {
                    buildDockerImageTask = project.task(taskName) {
                        logger.info "Skipping ${taskName} because ${dockerfileName} does not exist."
                    }
                }

                buildDockerImageTask.dependsOn copyFilesTask
                allTask.dependsOn buildDockerImageTask
            })

            // This probably isn't actually necessary, but keeping it for compatibility with the old airbyte-docker plugin
            project.build.dependsOn allTask
        }
    }

    static def createTask(Project project, String taskName, String imageName, String dockerfileName, String archOverride) {
        def buildDockerImageTask = project.task(taskName, type: DockerBuildImage) {
            def jdkVersion = System.getenv('JDK_VERSION') ?: '17.0.1'

            def arch = System.getenv('BUILD_ARCH') ?: System.getProperty("os.arch").toLowerCase()

            if (archOverride != null) {
                arch = archOverride
            }
            def isArm64 = arch == "aarch64" || arch == "arm64"

            // TODO should the other env vars also be affected by archOverride?
            // normalization doesn't depend on any of them, but plausibly other modules could need this?
            def buildPlatform = System.getenv('DOCKER_BUILD_PLATFORM') ?: isArm64 ? 'linux/arm64' : 'linux/amd64'
            if (archOverride != null) {
                buildPlatform = 'linux/amd64'
            }
            def alpineImage = System.getenv('ALPINE_IMAGE') ?: isArm64 ? 'arm64v8/alpine:3.14' : 'amd64/alpine:3.14'
            def nginxImage = System.getenv('NGINX_IMAGE') ?: isArm64 ? 'arm64v8/nginx:1.19-alpine' : 'amd64/nginx:1.19-alpine'
            def openjdkImage = System.getenv('JDK_IMAGE') ?: isArm64 ? "arm64v8/openjdk:${jdkVersion}-slim" : "amd64/openjdk:${jdkVersion}-slim"
            def buildArch = System.getenv('DOCKER_BUILD_ARCH') ?: isArm64 ? 'arm64' : 'amd64'

            inputDir = project.file("${project.projectDir}/build/docker")
            platform = buildPlatform
            images.add("airbyte/${imageName}")
            buildArgs.put('JDK_VERSION', jdkVersion)
            buildArgs.put('DOCKER_BUILD_ARCH', buildArch)
            buildArgs.put('ALPINE_IMAGE', alpineImage)
            buildArgs.put('NGINX_IMAGE', nginxImage)
            buildArgs.put('JDK_IMAGE', openjdkImage)
            buildArgs.put('VERSION', "${project.rootProject.ext.version}")

            dockerFile = project.file("build/docker/${dockerfileName}")
        }

        return buildDockerImageTask
    }
}
